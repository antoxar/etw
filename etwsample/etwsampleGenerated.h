//**********************************************************************`
//* This is an include file generated by Message Compiler.             *`
//*                                                                    *`
//* Copyright (c) Microsoft Corporation. All Rights Reserved.          *`
//**********************************************************************`
#pragma once
#include <wmistr.h>
#include <evntrace.h>
#include "evntprov.h"
//
//  Initial Defs
//
#if !defined(ETW_INLINE)
#define ETW_INLINE DECLSPEC_NOINLINE __inline
#endif

#if defined(__cplusplus)
extern "C" {
#endif

//
// Allow Diasabling of code generation
//
#ifndef MCGEN_DISABLE_PROVIDER_CODE_GENERATION
#if  !defined(McGenDebug)
#define McGenDebug(a,b)
#endif 


#if !defined(MCGEN_TRACE_CONTEXT_DEF)
#define MCGEN_TRACE_CONTEXT_DEF
typedef struct _MCGEN_TRACE_CONTEXT
{
    TRACEHANDLE     RegistrationHandle;
    TRACEHANDLE     Logger;
    ULONGLONG       MatchAnyKeyword;
    ULONGLONG       MatchAllKeyword;
    ULONG           Flags;
    ULONG           IsEnabled;
    UCHAR           Level; 
    UCHAR           Reserve;
} MCGEN_TRACE_CONTEXT, *PMCGEN_TRACE_CONTEXT;
#endif

#if !defined(MCGEN_EVENT_ENABLED_DEF)
#define MCGEN_EVENT_ENABLED_DEF
FORCEINLINE
BOOLEAN
McGenEventEnabled(
    __in PMCGEN_TRACE_CONTEXT EnableInfo,
    __in PCEVENT_DESCRIPTOR EventDescriptor
    )
{
    //
    // Check if the event Level is lower than the level at which
    // the channel is enabled.
    // If the event Level is 0 or the channel is enabled at level 0,
    // all levels are enabled.
    //

    if ((EventDescriptor->Level <= EnableInfo->Level) || // This also covers the case of Level == 0.
        (EnableInfo->Level == 0)) {

        //
        // Check if Keyword is enabled
        //

        if ((EventDescriptor->Keyword == (ULONGLONG)0) ||
            ((EventDescriptor->Keyword & EnableInfo->MatchAnyKeyword) &&
             ((EventDescriptor->Keyword & EnableInfo->MatchAllKeyword) == EnableInfo->MatchAllKeyword))) {
            return TRUE;
        }
    }

    return FALSE;

}
#endif


//
// EnableCheckMacro
//
#ifndef MCGEN_ENABLE_CHECK
#define MCGEN_ENABLE_CHECK(Context, Descriptor) (Context.IsEnabled &&  McGenEventEnabled(&Context, &Descriptor))
#endif

#if !defined(MCGEN_CONTROL_CALLBACK)
#define MCGEN_CONTROL_CALLBACK

DECLSPEC_NOINLINE __inline
VOID
__stdcall
McGenControlCallbackV2(
    __in LPCGUID SourceId,
    __in ULONG ControlCode,
    __in UCHAR Level,
    __in ULONGLONG MatchAnyKeyword,
    __in ULONGLONG MatchAllKeyword,
    __in_opt PEVENT_FILTER_DESCRIPTOR FilterData,
    __inout_opt PVOID CallbackContext
    )
/*++

Routine Description:

    This is the notification callback for Vista.

Arguments:

    SourceId - The GUID that identifies the session that enabled the provider. 

    ControlCode - The parameter indicates whether the provider 
                  is being enabled or disabled.

    Level - The level at which the event is enabled.

    MatchAnyKeyword - The bitmask of keywords that the provider uses to 
                      determine the category of events that it writes.

    MatchAllKeyword - This bitmask additionally restricts the category 
                      of events that the provider writes. 

    FilterData - The provider-defined data.

    CallbackContext - The context of the callback that is defined when the provider 
                      called EtwRegister to register itself.

Remarks:

    ETW calls this function to notify provider of enable/disable

--*/
{
    PMCGEN_TRACE_CONTEXT Ctx = (PMCGEN_TRACE_CONTEXT)CallbackContext;
#ifndef MCGEN_PRIVATE_ENABLE_CALLBACK_V2
    UNREFERENCED_PARAMETER(SourceId);
    UNREFERENCED_PARAMETER(FilterData);
#endif

    if (Ctx == NULL) {
        return;
    }

    switch (ControlCode) {

        case EVENT_CONTROL_CODE_ENABLE_PROVIDER:
            Ctx->Level = Level;
            Ctx->MatchAnyKeyword = MatchAnyKeyword;
            Ctx->MatchAllKeyword = MatchAllKeyword;
            Ctx->IsEnabled = EVENT_CONTROL_CODE_ENABLE_PROVIDER;
            break;

        case EVENT_CONTROL_CODE_DISABLE_PROVIDER:
            Ctx->IsEnabled = EVENT_CONTROL_CODE_DISABLE_PROVIDER;
            Ctx->Level = 0;
            Ctx->MatchAnyKeyword = 0;
            Ctx->MatchAllKeyword = 0;
            break;
 
        default:
            break;
    }

#ifdef MCGEN_PRIVATE_ENABLE_CALLBACK_V2
    //
    // Call user defined callback
    //
    MCGEN_PRIVATE_ENABLE_CALLBACK_V2(
        SourceId,
        ControlCode,
        Level,
        MatchAnyKeyword,
        MatchAllKeyword,
        FilterData,
        CallbackContext
        );
#endif
   
    return;
}

#endif
#endif // MCGEN_DISABLE_PROVIDER_CODE_GENERATION
//+
// Provider SampleProvider Event Count 4
//+
EXTERN_C __declspec(selectany) const GUID SAMPLE_PROVIDER_GUID = {0x2b2ccca2, 0x6c9c, 0x4c15, {0xb2, 0x0c, 0x7e, 0xe3, 0x71, 0xea, 0xce, 0x64}};

//
// Opcodes
//
#define OPCODE_INITIALIZE 0xe
#define OPCODE_CLEANUP 0xf
#define OPCODE_DOWNLOAD_XFER 0xb
#define OPCODE_UPLOAD_XFER 0xc
#define OPCODE_UPLOADREPLY_XFER 0xd
#define OPCODE_GET_RULES 0x10

//
// Tasks
//
#define TASK_TRANSFER 0x1
#define TASK_VALIDATE 0x2

//
// Event Descriptors
//
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR TRANSFER_SCHEDULE_EVENT = {0x1, 0x0, 0x0, 0x4, 0x0, 0x1, 0x0};
#define TRANSFER_SCHEDULE_EVENT_value 0x1
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR DOWNLOAD_XFER_FAILED_EVENT = {0x2, 0x0, 0x0, 0x2, 0xb, 0x1, 0x0};
#define DOWNLOAD_XFER_FAILED_EVENT_value 0x2
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR TEMPFILE_CLEANUP_EVENT = {0x3, 0x0, 0x0, 0x3, 0xf, 0x1, 0x0};
#define TEMPFILE_CLEANUP_EVENT_value 0x3
EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ANTOXAR_TRACE_EVENT = {0xff, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0};
#define ANTOXAR_TRACE_EVENT_value 0xff

//
// Note on Generate Code from Manifest Windows Vista and above
//
//Structures :  are handled as a size and pointer pairs. The macro for the event will have an extra 
//parameter for the size in bytes of the structure. Make sure that your structures have no extra padding.
//
//Strings: There are several cases that can be described in the manifest. For array of variable length 
//strings, the generated code will take the count of characters for the whole array as an input parameter. 
//
//SID No support for array of SIDs, the macro will take a pointer to the SID and use appropriate 
//GetLengthSid function to get the length.
//

//
// Allow Diasabling of code generation
//
#ifndef MCGEN_DISABLE_PROVIDER_CODE_GENERATION

//
// Globals 
//

EXTERN_C __declspec(selectany) REGHANDLE SampleProviderHandle = (REGHANDLE)0;

EXTERN_C __declspec(selectany) MCGEN_TRACE_CONTEXT SAMPLE_PROVIDER_GUID_Context = {0};

#if !defined(McGenEventRegisterUnregister)
#define McGenEventRegisterUnregister
DECLSPEC_NOINLINE __inline
ULONG __stdcall
McGenEventRegister(
    __in LPCGUID ProviderId,
    __in_opt PENABLECALLBACK EnableCallback,
    __in_opt PVOID CallbackContext,
    __inout PREGHANDLE RegHandle
    )
/*++

Routine Description:

    This function register the provider with ETW USER mode.

Arguments:
    ProviderId - Provider Id to be register with ETW.

    EnableCallback - Callback to be used.

    CallbackContext - Context for this provider.

    RegHandle - Pointer to Registration handle.

Remarks:

    If the handle != NULL will return ERROR_SUCCESS

--*/
{
    ULONG Error;


    if (*RegHandle) {
        //
        // already registered
        //
        return ERROR_SUCCESS;
    }

    Error = EventRegister( ProviderId, EnableCallback, CallbackContext, RegHandle); 

    return Error;
}


DECLSPEC_NOINLINE __inline
ULONG __stdcall
McGenEventUnregister(__inout PREGHANDLE RegHandle)
/*++

Routine Description:

    Unregister from ETW USER mode

Arguments:
            RegHandle this is the pointer to the provider context
Remarks:
            If Provider has not register RegHandle = NULL,
            return ERROR_SUCCESS
--*/
{
    ULONG Error;


    if(!(*RegHandle)) {
        //
        // Provider has not registerd
        //
        return ERROR_SUCCESS;
    }

    Error = EventUnregister(*RegHandle); 
    *RegHandle = (REGHANDLE)0;
    
    return Error;
}
#endif
//
// Register with ETW Vista +
//
#ifndef EventRegisterSampleProvider
#define EventRegisterSampleProvider() McGenEventRegister(&SAMPLE_PROVIDER_GUID, McGenControlCallbackV2, &SAMPLE_PROVIDER_GUID_Context, &SampleProviderHandle) 
#endif

//
// UnRegister with ETW
//
#ifndef EventUnregisterSampleProvider
#define EventUnregisterSampleProvider() McGenEventUnregister(&SampleProviderHandle) 
#endif

//
// Event Macro for TRANSFER_SCHEDULE_EVENT
//
#define EventWriteTRANSFER_SCHEDULE_EVENT(TransferName, TransferType, Day)\
        MCGEN_ENABLE_CHECK(SAMPLE_PROVIDER_GUID_Context, TRANSFER_SCHEDULE_EVENT) ?\
        Template_zqq(SampleProviderHandle, &TRANSFER_SCHEDULE_EVENT, TransferName, TransferType, Day)\
        : ERROR_SUCCESS\

//
// Event Macro for DOWNLOAD_XFER_FAILED_EVENT
//
#define EventWriteDOWNLOAD_XFER_FAILED_EVENT(TransferName, ErrorCode, test1, bla)\
        MCGEN_ENABLE_CHECK(SAMPLE_PROVIDER_GUID_Context, DOWNLOAD_XFER_FAILED_EVENT) ?\
        Template_zdqq(SampleProviderHandle, &DOWNLOAD_XFER_FAILED_EVENT, TransferName, ErrorCode, test1, bla)\
        : ERROR_SUCCESS\

//
// Event Macro for TEMPFILE_CLEANUP_EVENT
//
//
// MC Note ::  Macro for Event id = 3
// For array of strings: needs to be in aconsecutive blob or memory
// and make sure you pass the count or characters in blob including null terminators
//
#define EventWriteTEMPFILE_CLEANUP_EVENT(FilesCount, Files_Len_, Files, Path)\
        MCGEN_ENABLE_CHECK(SAMPLE_PROVIDER_GUID_Context, TEMPFILE_CLEANUP_EVENT) ?\
        Template_hZRz(SampleProviderHandle, &TEMPFILE_CLEANUP_EVENT, FilesCount, Files_Len_, Files, Path)\
        : ERROR_SUCCESS\

//
// Event Macro for ANTOXAR_TRACE_EVENT
//
#define EventWriteANTOXAR_TRACE_EVENT(func, line, tracestr1)\
        MCGEN_ENABLE_CHECK(SAMPLE_PROVIDER_GUID_Context, ANTOXAR_TRACE_EVENT) ?\
        Template_sqs(SampleProviderHandle, &ANTOXAR_TRACE_EVENT, func, line, tracestr1)\
        : ERROR_SUCCESS\

#endif // MCGEN_DISABLE_PROVIDER_CODE_GENERATION


//
// Allow Diasabling of code generation
//
#ifndef MCGEN_DISABLE_PROVIDER_CODE_GENERATION

//
// Template Functions 
//
//
//Template from manifest : t2
//
#ifndef Template_zqq_def
#define Template_zqq_def
ETW_INLINE
ULONG
Template_zqq(
    __in REGHANDLE RegHandle,
    __in PCEVENT_DESCRIPTOR Descriptor,
    __in_opt PCWSTR  TransferName,
    __in const unsigned int  TransferType,
    __in const unsigned int  Day
    )
{
#define ARGUMENT_COUNT_zqq 3

    EVENT_DATA_DESCRIPTOR EventData[ARGUMENT_COUNT_zqq];

    EventDataDescCreate(&EventData[0], 
                        (TransferName != NULL) ? TransferName : L"NULL",
                        (TransferName != NULL) ? (ULONG)((wcslen(TransferName) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[1], &TransferType, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[2], &Day, sizeof(const unsigned int)  );

    return EventWrite(RegHandle, Descriptor, ARGUMENT_COUNT_zqq, EventData);
}
#endif

//
//Template from manifest : t3
//
#ifndef Template_zdqq_def
#define Template_zdqq_def
ETW_INLINE
ULONG
Template_zdqq(
    __in REGHANDLE RegHandle,
    __in PCEVENT_DESCRIPTOR Descriptor,
    __in_opt PCWSTR  TransferName,
    __in const signed int  ErrorCode,
    __in const unsigned int  test1,
    __in const unsigned int  bla
    )
{
#define ARGUMENT_COUNT_zdqq 4

    EVENT_DATA_DESCRIPTOR EventData[ARGUMENT_COUNT_zdqq];

    EventDataDescCreate(&EventData[0], 
                        (TransferName != NULL) ? TransferName : L"NULL",
                        (TransferName != NULL) ? (ULONG)((wcslen(TransferName) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    EventDataDescCreate(&EventData[1], &ErrorCode, sizeof(const signed int)  );

    EventDataDescCreate(&EventData[2], &test1, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[3], &bla, sizeof(const unsigned int)  );

    return EventWrite(RegHandle, Descriptor, ARGUMENT_COUNT_zdqq, EventData);
}
#endif

//
//Template from manifest : t4
//
#ifndef Template_hZRz_def
#define Template_hZRz_def
ETW_INLINE
ULONG
Template_hZRz(
    __in REGHANDLE RegHandle,
    __in PCEVENT_DESCRIPTOR Descriptor,
    __in const unsigned short  FilesCount,
    __in ULONG Files_Len_,
    __in_ecount(FilesCount) PCWSTR  Files,
    __in_opt PCWSTR  Path
    )
{
#define ARGUMENT_COUNT_hZRz 3

    EVENT_DATA_DESCRIPTOR EventData[ARGUMENT_COUNT_hZRz];

    EventDataDescCreate(&EventData[0], &FilesCount, sizeof(const unsigned short)  );

    EventDataDescCreate(&EventData[1], Files, (ULONG)(sizeof(WCHAR)*Files_Len_));

    EventDataDescCreate(&EventData[2], 
                        (Path != NULL) ? Path : L"NULL",
                        (Path != NULL) ? (ULONG)((wcslen(Path) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));

    return EventWrite(RegHandle, Descriptor, ARGUMENT_COUNT_hZRz, EventData);
}
#endif

//
//Template from manifest : t_func_line
//
#ifndef Template_sqs_def
#define Template_sqs_def
ETW_INLINE
ULONG
Template_sqs(
    __in REGHANDLE RegHandle,
    __in PCEVENT_DESCRIPTOR Descriptor,
    __in_opt LPCSTR  func,
    __in const unsigned int  line,
    __in_opt LPCSTR  tracestr1
    )
{
#define ARGUMENT_COUNT_sqs 3

    EVENT_DATA_DESCRIPTOR EventData[ARGUMENT_COUNT_sqs];

    EventDataDescCreate(&EventData[0], 
                        (func != NULL) ? func : "NULL",
                        (func != NULL) ? (ULONG)((strlen(func) + 1) * sizeof(CHAR)) : (ULONG)sizeof("NULL"));

    EventDataDescCreate(&EventData[1], &line, sizeof(const unsigned int)  );

    EventDataDescCreate(&EventData[2], 
                        (tracestr1 != NULL) ? tracestr1 : "NULL",
                        (tracestr1 != NULL) ? (ULONG)((strlen(tracestr1) + 1) * sizeof(CHAR)) : (ULONG)sizeof("NULL"));

    return EventWrite(RegHandle, Descriptor, ARGUMENT_COUNT_sqs, EventData);
}
#endif

#endif // MCGEN_DISABLE_PROVIDER_CODE_GENERATION

#if defined(__cplusplus)
};
#endif

#define MSG_Task_Transfer_Download           0x3000000BL
#define MSG_Task_Transfer_Upload             0x3000000CL
#define MSG_Task_Transfer_UploadReply        0x3000000DL
#define MSG_Opcode_Initialize                0x3000000EL
#define MSG_Opcode_Cleanup                   0x3000000FL
#define MSG_Task_Validate_GetRules           0x30000010L
#define MSG_level_LogAlways                  0x50000000L
#define MSG_level_Error                      0x50000002L
#define MSG_level_Warning                    0x50000003L
#define MSG_level_Informational              0x50000004L
#define MSG_Task_Transfer                    0x70000001L
#define MSG_Task_Validate                    0x70000002L
#define MSG_Provider_Name                    0x90000001L
#define MSG_Event_XferSchedule               0xB0000001L
#define MSG_Event_DownloadFailed             0xB0000002L
#define MSG_Event_TempFilesNotDeleted        0xB0000003L
#define MSG_Microsoft_Windows_SampleProvider_event_255_message 0xB00100FFL
#define MSG_Microsoft_Windows_SampleProvider_map_AntoxarStrings_1_message 0xD0000001L
#define MSG_Microsoft_Windows_SampleProvider_map_AntoxarStrings_2_message 0xD0000002L
#define MSG_TransferType_Download            0xD0000003L
#define MSG_TransferType_Upload              0xD0000004L
#define MSG_TransferType_UploadReply         0xD0000005L
#define MSG_DaysOfTheWeek_Sunday             0xF0000001L
#define MSG_DaysOfTheWeek_Monday             0xF0000002L
#define MSG_DaysOfTheWeek_Tuesday            0xF0000003L
#define MSG_DaysOfTheWeek_Wednesday          0xF0000004L
#define MSG_DaysOfTheWeek_Thursday           0xF0000005L
#define MSG_DaysOfTheWeek_Friday             0xF0000006L
#define MSG_DaysOfTheWeek_Saturday           0xF0000007L
